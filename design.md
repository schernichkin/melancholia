# Модель выполнения

Общая схема
1. Разбор входного запроса.
2. Постноение графа задач.
3. Шедулинг задач на исполнителях.

Программа представлена ацикличным направленным графом задач.

> Возможно следует ввести поддержку циклов?

Каждая задача имеет один или несколько входных каналов, по которым получает
сообщения и один выходной канал (его могут слушать несколько задач), в который
она пишет результат. Работают задачи в поточном режиме (результат записывается
в выходной канал как только он готов).

Задачи запускаются на исполнителях.

Должна быть поддержка динамического создания задач (для разбиения задачи).

## Шедулинг

Имеется набор исполнителей с ограничениями по памяти и граф задач, про каждую
из которых известен максимальный размер используемых ей буферов. Требуется
запускать задачи в порядке, обеспечивающим максимально быстрое исполнение и
минимизацию записи данных на диск.

Задачи работают в push-режиме в стиле reactive streams. Это значит, что источник
не посылает сообщения, пока принимающая сторона не готова. Шедулинг может
приводить к зависаниям - отправляющая сторона держит память, из-за этого не
получается запустить принимающую сторону. Поэтому требуются какие-нибудь
механизмы для временного освобождения ресурсов (например, сохранение всех
сообщений отправляющей стороны чтобы дать ей возможность завершиться и освободить
буферы).

Общий вид шедулера:
- Набор задач (причем задачи могут добавляться в процессе работы).
- Набор исполнителей.
Шедулер решает в какой момент времери какую задачу послать на какой исполнитель.
При этом все зависимые от неё задачи должны быть либо активны, либо заменены
"буферными" задачами, которые могут принять сообщения вместо реальной. Шедулер
должен стремиться к тому, чтобы в каждый момент времени утилизация кластера была
максимальной, а количество "буферных" задач - минимальным.

## Динамическое выделение ресурсов для задачи

Даже если нам известна кардинальность данных, нам может быть не известно реально
необходимое количество ресурсов (из-за переменного размера данных). Поэтому было
бы неплохо уметь выделять буферы динамически. При этом может произойти ситуация,
когда исполнитель не может выделить задача достаточно ресурсов. В этом случае
нужно будет принять решение об остановке одной из задач и сохранении всех её
результатов на диск. Дальне надо принять решение инсталировать ли для её входов
буферы, и как будут вести себя эти буферы (писать на диск, либо в память).

## Динамическое создание задач

Необходимо уметь менять граф задач в реальном времени.

## Свойства исполнителя
- Вместимость (сколько доступно оперативной памяти, процессорных ядер, памяти на диске).
- Расположение (где он физически находится относильно данных, возможно, расположение
  относительно других исполнителей)

## Свойства задач

Каждая задача обладает общими свойствами и дополнительным специфичным набором
свойств. Общие свойства:
- Размер буферов. Мы не можем (легко) гарантировать орграничения по размеру
  памяти для произвольного алгоритма, но для хранения данных должны использоваться
  только управляемые буферы.

> Размер буферов может быть функцией от кол-ва входных данных.

> Интересным решением была бы возможность автоматического разбиения задач, если
> они получаются слишком большими.

- Кардинальность выходного датасета (возможно, размер..)

### Чтение раздела
- Физическое расположение раздела (на каком исполнителе)
- Размер раздела

### Сумма
- ничего дополнительного.
